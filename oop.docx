OOPS
The OOP paradigm has the following four features:
Inheritance
Encapsulation
Polymorphism
Data Abstraction

9) What do you understand by pure object-oriented language? Why is Java not a pure object-oriented programming language?
A programming language is called a pure object-oriented language when it treats everything inside the program as an object. Pure object-oriented languages do not support primitive types. To be considered pure, a language must satisfy certain features:
Encapsulation
Inheritance
Polymorphism
Abstraction
All predefined types are objects
All user-defined types are objects
All operations performed on objects must be done through methods exposed by the objects
Java is not a pure object-oriented programming language because it includes primitive data types (e.g., int, float, char, boolean) that are not objects. These primitives are provided for performance optimization, which prevents Java from being classified as purely object-oriented.
Example of Pure Object-Oriented Language
Ruby is considered close to a pure object-oriented language because even primitive data types like integers and strings are treated as objects.
5.times { puts "Hello" }  # 5 is an object, and `times` is a method.
puts 7.class              # Outputs "Integer", showing 7 is an object.

13) What is the concept of access specifiers, and when should we use them?
In OOP, access specifiers are reserved keywords used to define the accessibility of classes, methods, and other class members. These are also referred to as access modifiers. Common access specifiers include:
Public: Accessible from anywhere in the program.
Private: Accessible only within the same class.
Protected: Accessible within the same package and by subclasses.
Some languages, like Java, include additional specifiers, such as default, which allows access within the same package. Access specifiers are crucial for achieving encapsulation, one of the core principles of OOP.

14) What are the manipulators in OOP, and how do they work?
Manipulators are helper functions used to modify or format the input/output stream in programming. They work in conjunction with the insertion (<<) and extraction (>>) operators but do not alter variable values.
Types of Manipulators:
Manipulators Without Arguments: These affect the input/output streams directly.
endl: Inserts a newline character and flushes the output buffer.
ws: Ignores leading whitespaces in the input.
flush: Explicitly flushes the output buffer.
Example:
std::cout << "Hello" << std::endl;  // Outputs "Hello" followed by a newline.
Manipulators With Arguments: These accept arguments to format the stream.
setw(val): Sets the width of the field for the next input/output.
setfill(c): Fills unused width with a specified character.
setbase(val): Sets the base for integer output (e.g., decimal, octal, or hexadecimal).
setiosflags(flag): Sets specific format flags like fixed or scientific.
Example:
std::cout << std::setw(10) << std::setfill('*') << 123;  // Outputs "*******123"

15) What are the rules for creating a constructor?
A constructor is a special method in OOP used to initialize objects. It must adhere to these rules:
It cannot have a return type.
It must have the same name as the class name.
It cannot be marked as static.
It cannot be marked as abstract.
It cannot be overridden.
It cannot be final.

Differences Between Errors and Exceptions in Java
Recoverable vs. Irrecoverable: Exceptions can be recovered using mechanisms like try-catch blocks, allowing programs to handle unexpected situations gracefully. Errors, however, are typically unrecoverable and indicate serious problems, such as running out of memory.
Type: Exceptions are classified into checked and unchecked categories. Checked exceptions must be explicitly handled, while errors are always unchecked and signify critical issues beyond the application's control.
Occurrence: Exceptions can occur at compile time (checked exceptions) or runtime (unchecked exceptions). Errors occur only at runtime and often terminate the program.
Package: Exceptions belong to the java.lang.Exception package, while errors belong to the java.lang.Error package.
Known or Unknown: Checked exceptions are known to the compiler, requiring handling using try-catch or throws. Errors are not known to the compiler as they are unpredictable.
Causes: Exceptions are usually caused by issues in the application, such as invalid input or logic errors. Errors result from problems in the environment or system resources, such as memory leaks or stack overflow.
Examples:
Exceptions:
Checked: SQLException, IOException.
Unchecked: ArrayIndexOutOfBoundsException, NullPointerException.
Errors: OutOfMemoryError, StackOverflowError, VirtualMachineError.








// Abstract class
abstract class Animal {
    // Abstract method (does not have a body)
    public abstract void sound();

    // Regular method
    public void sleep() {
        System.out.println("The animal is sleeping.");
    }
}

// Subclass (inherited from Animal)
class Dog extends Animal {
    // Providing implementation for the abstract method
    public void sound() {
        System.out.println("The dog barks.");
    }
}

class Main {
    public static void main(String[] args) {
        // Cannot instantiate an abstract class
        // Animal animal = new Animal(); // This will give an error
        
        // Create an object of the Dog class
        Animal dog = new Dog();
        
        // Calling methods
        dog.sound();  // Outputs: The dog barks.
        dog.sleep();  // Outputs: The animal is sleeping.
    }
}

An abstract class is a class that is declared as abstract. 
It cannot be instantiated and is always used as a base class. 
The characteristics of an abstract class are as follows: Instantiation of an abstract class is not allowed. 
It must be inherited.
An abstract class can have both abstract and non-abstract methods.
An abstract class must have at least one abstract method.
You must declare at least one abstract method in the abstract class.
It is always public.
It is declared using the abstract
The purpose of an abstract class is to provide a common definition of the base class that multiple derived classes can share.

20) Is it possible for a class to inherit the constructor of its base class? 

No, a class cannot inherit the constructor of its base class.

In Java, a subclass cannot inherit the constructor of its base (or parent) class. However, a subclass can call the constructor of its parent class using the super() keyword. This is not the same as inheriting the constructor, as the subclass must explicitly invoke the parent class constructor.


// Base class
class Animal {
    // Constructor of the base class
    public Animal(String name) {
        System.out.println("Animal name: " + name);
    }
}

// Subclass
class Dog extends Animal {
    // Constructor of the subclass
    public Dog(String name) {
        // Calling the constructor of the base class
        super(name);  // This is not inheritance, it's explicit invocation
        System.out.println("Dog name: " + name);
    }
}

class Main {
    public static void main(String[] args) {
        // Creating an object of the Dog class
        Dog dog = new Dog("Buddy");
    }
}

Animal name: Buddy
Dog name: Buddy


21) Identify which OOPs concept should be used in the following scenario?
A group of 5 friends, one boy never gives any contribution when the group goes for the outing. Suddenly a beautiful girl joins the same group. The boy who never contributes is now spending a lot of money for the group.
Runtime Polymorphism

Explanation of Runtime Polymorphism:
Polymorphism means the ability of a single function or method to behave differently based on the object that invokes it.
Runtime Polymorphism occurs when a method is called on an object, and the actual method that gets executed is determined at runtime, based on the type of the object being referred to.


22) What is composition?
Composition is one of the vital concepts in OOP. It describes a class that references one or more objects of other classes in instance variables. It allows us to model a has-a association between objects. We can find such relationships in the real world. For example, a car has an engine. the following figure depicts the same







23) What are the differences between copy constructor and assignment operator?
The copy constructor and the assignment operator (=) both are used to initialize one object using another object. The main difference between the two is that the copy constructor allocates separate memory to both objects i.e. existing object and newly created object while the assignment operator does not allocate new memory for the newly created object. It uses the reference variable that points to the previous memory block (where an old object is located).
Syntax of Copy Constructor
class_name (const class_name &obj)  
{  
//body  
}  
Syntax of Assignment Operator
class_name obj1, obj2;  
obj1=obj2;  


24) What is the difference between Composition and Inheritance?
Inheritance means an object inheriting reusable properties of the base class. Compositions mean that an object holds other objects. In Inheritance, there is only one object in memory (derived object) whereas, in Composition, the parent object holds references of all composed objects. From a design perspective, inheritance is "is a" relationship among objects whereas Composition is "has a" relationship among objects.
25) What is constructor chaining?
In OOPs, constructor chaining is a sequence of invoking constructors (of the same class) upon initializing an object. It is used when we want to invoke a number of constructors, one after another by using only an instance. In other words, if a class has more than one constructor (overloaded) and one of them tries to invoke another constructor, this process is known as constructor chaining. In C++, it is known as constructor delegation and it is present from C++ 11.



//---- 


